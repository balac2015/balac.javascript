字符匹配：字符组 []、量词 {}、多选分支 |

两种模糊匹配：横向模糊匹配、纵向模糊匹配

    横向模糊匹配：一个正则可匹配的字符串的长度不是固定的

        实现方式是使用量词。{m,n}，表示连续出现最少m次，最多n次

        /ab{2,5}c/ 匹配：第一个字符是a，接下来是2到5个字符b，最后是c

        "abc abbc abbbc abbbbc abbbbbc abbbbbbc".match(/ab{2,5}c/g);    // [ 'abbc', 'abbbc', 'abbbbc', 'abbbbbc' ]

    纵向模糊匹配：个正则匹配的字符串，具体到某一位字符时，它可以不是某个确定的字符，可以有多种可能

        实现方式是使用字符组。[abc]，表示该字符可以是a、b、c中的任何一个。

        "a0b a1b a2b a3b a4b".match(/a[123]b/g);        // [ 'a1b', 'a2b', 'a3b' ]

字符组：只是匹配其中一个字符。[abc]表示匹配一个字符，它可以是a、b、c。

    范围表示法：字符组里的字符比较多，可以使用范围表示法。

        [123456abcdefGHIJKLM]可以写成[1-6a-fG-M]。用连字符-来省略和简写。

        匹配a、-、z这三者中任意一个字符，可以写成[-az]或[a\-z]。要么放在开头，要么放在结尾，要么转义

    排除字符组：纵向模糊匹配某位字符不能是a、b、c （[^abc]）

        [^abc]表示一个除a、b、c之外的任意一个字符。字符组的第一位放^（脱字符），表示求反的概念。

    常见的简写形式:


        \d就是[0-9]。表示一位数字。digit

        \D就是[^0-9]。表示除数字外的任意字符

        \w就是[0-9a-zA-Z]。表示数字、大小写字母和下划线。word

        \W就是[^0-9a-zA-Z]。非单词字符

        \s就是[\t\v\n\r\f]。表示空白符，包括空格、水平制表符、垂直制表符、换行符、回车符、换页符。space

        \S就是[^\t\v\n\r\f]。非空白符

        .就是[^\n\r\u2028\u2029]。通配符，表示所有任意字符。

    匹配任意字符，可以使用[\d\D]、[\w\W]、[\s\S]、[^]中任意一个。

量词：量词也称重复。{m,n}

    简写形式

        {m,} 表示至少出现m次

        {m} 等价于{m,m}，表示出现m次

        ? 等价于{0,1}，表示出现或不出现

        + 等价于{1,}，表示出现至少一次。

        * 等价于{0,}，表示出现任意次，有可能不出现。

    贪婪匹配和惰性匹配

        贪婪匹配，就会尽可能多的匹配。

            "123 1234 12345 123456".match(/\d{2,5}/g);      // [ '123', '1234', '12345', '12345' ]

        惰性匹配，就会尽可能少的匹配。

            "123 1234 12345 123456".match(/\d{2,5}?/g);     // [ '12', '12', '34', '12', '34', '12', '34', '56' ]

            /\d{2,5}?/g 表示2到5次都行，当2个就够的时候，不再往下匹配。

        通过在量词后面加?就能实现惰性匹配，所有的惰性匹配情形

            {m,n}?

            {m,}?

            ??

            +?

            *?
        .* 是贪婪模式

        .*? 是惰性模式

多选分支：多选分支可以支持多个子模式任选其一，一个模式可以实现横向和纵向模糊匹配

    (p1|p2|p3)其中p1、p2和p3是子模式，用|（管道符）分隔，表示其中任何一个。

    "good idea, nice try.".match(/good|nice/g); // [ 'good', 'nice' ]

    "goodbye".match(/good|goodbye/g);           // ["good"]，"goodbye" 匹配到了 good 模式，就不会再去匹配 goodbye 模式了

    "goodbye".match(/goodbye|good/g);           // ["goodbye"]

    分支结构也是惰性的，即当前面的匹配好了，后面的不再尝试。（匹配到了 p1 就不会再去匹配 p2）
